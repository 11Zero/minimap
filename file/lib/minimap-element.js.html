<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/minimap-element.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/atom-minimap/minimap" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/decoration.js~Decoration.html">Decoration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/main.js~Main.html">Main</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/minimap-element.js~MinimapElement.html">MinimapElement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/minimap.js~Minimap.html">Minimap</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">decorators</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-element">element</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-include">include</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">mixins</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/mixins/canvas-drawer.js~CanvasDrawer.html">CanvasDrawer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/mixins/decoration-management.js~DecorationManagement.html">DecorationManagement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/mixins/dom-styles-reader.js~DOMStylesReader.html">DOMStylesReader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/mixins/plugin-management.js~PluginManagement.html">PluginManagement</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/minimap-element.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use babel&apos;

import {CompositeDisposable, Disposable} from &apos;atom&apos;
import {EventsDelegation, AncestorsMethods} from &apos;atom-utils&apos;
import include from &apos;./decorators/include&apos;
import element from &apos;./decorators/element&apos;
import DOMStylesReader from &apos;./mixins/dom-styles-reader&apos;
import CanvasDrawer from &apos;./mixins/canvas-drawer&apos;
import MinimapQuickSettingsElement from &apos;./minimap-quick-settings-element&apos;

const SPEC_MODE = atom.inSpecMode()

/**
 * Public: The MinimapElement is the view meant to render a {@link Minimap}
 * instance in the DOM.
 *
 * You can retrieve the MinimapElement associated to a Minimap
 * using the `atom.views.getView` method.
 *
 * Note that most interactions with the Minimap package is done through the
 * Minimap model so you should never have to access MinimapElement
 * instances.
 *
 * @example
 * let minimapElement = atom.views.getView(minimap)
 */
@element(&apos;atom-text-editor-minimap&apos;)
@include(DOMStylesReader, CanvasDrawer, EventsDelegation, AncestorsMethods)
export default class MinimapElement {

  /**
   * The method that registers the MinimapElement factory in the
   * `atom.views` registry with the Minimap model.
   */
  static registerViewProvider () {
    atom.views.addViewProvider(require(&apos;./minimap&apos;), function (model) {
      let element = new MinimapElement()
      element.setModel(model)
      return element
    })
  }

  //    ##     ##  #######   #######  ##    ##  ######
  //    ##     ## ##     ## ##     ## ##   ##  ##    ##
  //    ##     ## ##     ## ##     ## ##  ##   ##
  //    ######### ##     ## ##     ## #####     ######
  //    ##     ## ##     ## ##     ## ##  ##         ##
  //    ##     ## ##     ## ##     ## ##   ##  ##    ##
  //    ##     ##  #######   #######  ##    ##  ######

  /**
   * DOM callback invoked when a new MinimapElement is created.
   *
   * @access private
   */
  createdCallback () {
    // Core properties

    /**
     * @access private
     */
    this.minimap = undefined
    /**
     * @access private
     */
    this.editorElement = undefined
    /**
     * @access private
     */
    this.width = undefined
    /**
     * @access private
     */
    this.height = undefined

    // Subscriptions

    /**
     * @access private
     */
    this.subscriptions = new CompositeDisposable()
    /**
     * @access private
     */
    this.visibleAreaSubscription = undefined
    /**
     * @access private
     */
    this.quickSettingsSubscription = undefined
    /**
     * @access private
     */
    this.dragSubscription = undefined
    /**
     * @access private
     */
    this.openQuickSettingSubscription = undefined

    // Configs

    /**
    * @access private
    */
    this.displayMinimapOnLeft = false
    /**
    * @access private
    */
    this.minimapScrollIndicator = undefined
    /**
    * @access private
    */
    this.displayMinimapOnLeft = undefined
    /**
    * @access private
    */
    this.displayPluginsControls = undefined
    /**
    * @access private
    */
    this.textOpacity = undefined
    /**
    * @access private
    */
    this.displayCodeHighlights = undefined
    /**
    * @access private
    */
    this.adjustToSoftWrap = undefined
    /**
    * @access private
    */
    this.useHardwareAcceleration = undefined
    /**
    * @access private
    */
    this.absoluteMode = undefined

    // Elements

    /**
     * @access private
     */
    this.shadowRoot = undefined
    /**
     * @access private
     */
    this.visibleArea = undefined
    /**
     * @access private
     */
    this.controls = undefined
    /**
     * @access private
     */
    this.scrollIndicator = undefined
    /**
     * @access private
     */
    this.openQuickSettings = undefined
    /**
     * @access private
     */
    this.quickSettingsElement = undefined

    // States

    /**
    * @access private
    */
    this.attached = undefined
    /**
    * @access private
    */
    this.attachedToTextEditor = undefined
    /**
    * @access private
    */
    this.standAlone = undefined
    /**
     * @access private
     */
    this.wasVisible = undefined

    // Other

    /**
     * @access private
     */
    this.offscreenFirstRow = undefined
    /**
     * @access private
     */
    this.offscreenLastRow = undefined
    /**
     * @access private
     */
    this.frameRequested = undefined
    /**
     * @access private
     */
    this.flexBasis = undefined

    this.initializeContent()

    return this.observeConfig({
      &apos;minimap.displayMinimapOnLeft&apos;: (displayMinimapOnLeft) =&gt; {
        this.displayMinimapOnLeft = displayMinimapOnLeft

        this.updateMinimapFlexPosition()
      },

      &apos;minimap.minimapScrollIndicator&apos;: (minimapScrollIndicator) =&gt; {
        this.minimapScrollIndicator = minimapScrollIndicator

        if (this.minimapScrollIndicator &amp;&amp; !(this.scrollIndicator != null) &amp;&amp; !this.standAlone) {
          this.initializeScrollIndicator()
        } else if ((this.scrollIndicator != null)) {
          this.disposeScrollIndicator()
        }

        if (this.attached) { this.requestUpdate() }
      },

      &apos;minimap.displayPluginsControls&apos;: (displayPluginsControls) =&gt; {
        this.displayPluginsControls = displayPluginsControls

        if (this.displayPluginsControls &amp;&amp; !(this.openQuickSettings != null) &amp;&amp; !this.standAlone) {
          this.initializeOpenQuickSettings()
        } else if ((this.openQuickSettings != null)) {
          this.disposeOpenQuickSettings()
        }
      },

      &apos;minimap.textOpacity&apos;: (textOpacity) =&gt; {
        this.textOpacity = textOpacity

        if (this.attached) { this.requestForcedUpdate() }
      },

      &apos;minimap.displayCodeHighlights&apos;: (displayCodeHighlights) =&gt; {
        this.displayCodeHighlights = displayCodeHighlights

        if (this.attached) { this.requestForcedUpdate() }
      },

      &apos;minimap.adjustMinimapWidthToSoftWrap&apos;: (adjustToSoftWrap) =&gt; {
        this.adjustToSoftWrap = adjustToSoftWrap

        if (this.attached) { this.measureHeightAndWidth() }
      },

      &apos;minimap.useHardwareAcceleration&apos;: (useHardwareAcceleration) =&gt; {
        this.useHardwareAcceleration = useHardwareAcceleration

        if (this.attached) { this.requestUpdate() }
      },

      &apos;minimap.absoluteMode&apos;: (absoluteMode) =&gt; {
        this.absoluteMode = absoluteMode

        return this.classList.toggle(&apos;absolute&apos;, this.absoluteMode)
      },

      &apos;editor.preferredLineLength&apos;: () =&gt; {
        if (this.attached) { this.measureHeightAndWidth() }
      },

      &apos;editor.softWrap&apos;: () =&gt; {
        if (this.attached) { this.requestUpdate() }
      },

      &apos;editor.softWrapAtPreferredLineLength&apos;: () =&gt; {
        if (this.attached) { this.requestUpdate() }
      }
    })
  }

  /**
   * DOM callback invoked when a new MinimapElement is attached to the DOM.
   *
   * @access private
   */
  attachedCallback () {
    this.subscriptions.add(atom.views.pollDocument(() =&gt; { this.pollDOM() }))
    this.measureHeightAndWidth()
    this.updateMinimapFlexPosition()
    this.attached = true
    this.attachedToTextEditor = this.parentNode === this.getTextEditorElementRoot()

    /*
      We use `atom.styles.onDidAddStyleElement` instead of
      `atom.themes.onDidChangeActiveThemes`.
      Why? Currently, The style element will be removed first, and then re-added
      and the `change` event has not be triggered in the process.
    */
    return this.subscriptions.add(atom.styles.onDidAddStyleElement(() =&gt; {
      this.invalidateDOMStylesCache()
      this.requestForcedUpdate()
    }))
  }

  /**
   * DOM callback invoked when a new MinimapElement is detached from the DOM.
   *
   * @access private
   */
  detachedCallback () {
    this.attached = false
  }

  //       ###    ######## ########    ###     ######  ##     ##
  //      ## ##      ##       ##      ## ##   ##    ## ##     ##
  //     ##   ##     ##       ##     ##   ##  ##       ##     ##
  //    ##     ##    ##       ##    ##     ## ##       #########
  //    #########    ##       ##    ######### ##       ##     ##
  //    ##     ##    ##       ##    ##     ## ##    ## ##     ##
  //    ##     ##    ##       ##    ##     ##  ######  ##     ##

  /**
   * Returns whether the MinimapElement is currently visible on screen or not.
   *
   * The visibility of the minimap is defined by testing the size of the offset
   * width and height of the element.
   *
   * @return {boolean} whether the MinimapElement is currently visible or not
   */
  isVisible () { return this.offsetWidth &gt; 0 || this.offsetHeight &gt; 0 }

  /**
   * Attaches the MinimapElement to the DOM.
   *
   * The position at which the element is attached is defined by the
   * `displayMinimapOnLeft` setting.
   *
   * @param  {HTMLElement} [parent] the DOM node where attaching the minimap
   *                                element
   */
  attach (parent) {
    if (this.attached) { return }
    (parent || this.getTextEditorElementRoot()).appendChild(this)
  }

  /**
   * Detaches the MinimapElement from the DOM.
   */
  detach () {
    if (!this.attached || this.parentNode == null) { return }
    this.parentNode.removeChild(this)
  }

  /**
   * Toggles the minimap left/right position based on the value of the
   * `displayMinimapOnLeft` setting.
   *
   * @access private
   */
  updateMinimapFlexPosition () {
    this.classList.toggle(&apos;left&apos;, this.displayMinimapOnLeft)
  }

  /**
   * Destroys this MinimapElement
   */
  destroy () {
    this.subscriptions.dispose()
    this.detach()
    this.minimap = null
  }

  //     ######   #######  ##    ## ######## ######## ##    ## ########
  //    ##    ## ##     ## ###   ##    ##    ##       ###   ##    ##
  //    ##       ##     ## ####  ##    ##    ##       ####  ##    ##
  //    ##       ##     ## ## ## ##    ##    ######   ## ## ##    ##
  //    ##       ##     ## ##  ####    ##    ##       ##  ####    ##
  //    ##    ## ##     ## ##   ###    ##    ##       ##   ###    ##
  //     ######   #######  ##    ##    ##    ######## ##    ##    ##

  /**
   * Creates the content of the MinimapElement and attaches the mouse control
   * event listeners.
   *
   * @access private
   */
  initializeContent () {
    this.initializeCanvas()

    this.shadowRoot = this.createShadowRoot()
    this.attachCanvases(this.shadowRoot)

    this.createVisibleArea()
    this.createControls()

    this.subscriptions.add(this.subscribeTo(this, {
      &apos;mousewheel&apos;: (e) =&gt; {
        if (!this.standAlone) { this.relayMousewheelEvent(e) }
      }
    }))

    this.subscriptions.add(this.subscribeTo(this.getFrontCanvas(), {
      &apos;mousedown&apos;: (e) =&gt; { this.mousePressedOverCanvas(e) }
    }))
  }

  /**
   * Initializes the visible area div.
   *
   * @access private
   */
  createVisibleArea () {
    if (this.visibleArea) { return }

    this.visibleArea = document.createElement(&apos;div&apos;)
    this.visibleArea.classList.add(&apos;minimap-visible-area&apos;)
    this.shadowRoot.appendChild(this.visibleArea)
    this.visibleAreaSubscription = this.subscribeTo(this.visibleArea, {
      &apos;mousedown&apos;: (e) =&gt; { this.startDrag(e) },
      &apos;touchstart&apos;: (e) =&gt; { this.startDrag(e) }
    })

    this.subscriptions.add(this.visibleAreaSubscription)
  }

  /**
   * Removes the visible area div.
   *
   * @access private
   */
  removeVisibleArea () {
    if (!this.visibleArea) { return }

    this.subscriptions.remove(this.visibleAreaSubscription)
    this.visibleAreaSubscription.dispose()
    this.shadowRoot.removeChild(this.visibleArea)
    delete this.visibleArea
  }

  /**
   * Creates the controls container div.
   *
   * @access private
   */
  createControls () {
    if (this.controls || this.standAlone) { return }

    this.controls = document.createElement(&apos;div&apos;)
    this.controls.classList.add(&apos;minimap-controls&apos;)
    this.shadowRoot.appendChild(this.controls)
  }

  /**
   * Removes the controls container div.
   *
   * @access private
   */
  removeControls () {
    if (!this.controls) { return }

    this.shadowRoot.removeChild(this.controls)
    delete this.controls
  }

  /**
   * Initializes the scroll indicator div when the `minimapScrollIndicator`
   * settings is enabled.
   *
   * @access private
   */
  initializeScrollIndicator () {
    if (this.scrollIndicator || this.standAlone) { return }

    this.scrollIndicator = document.createElement(&apos;div&apos;)
    this.scrollIndicator.classList.add(&apos;minimap-scroll-indicator&apos;)
    this.controls.appendChild(this.scrollIndicator)
  }

  /**
   * Disposes the scroll indicator div when the `minimapScrollIndicator`
   * settings is disabled.
   *
   * @access private
   */
  disposeScrollIndicator () {
    if (!this.scrollIndicator) { return }

    this.controls.removeChild(this.scrollIndicator)
    delete this.scrollIndicator
  }

  /**
   * Initializes the quick settings openener div when the
   * `displayPluginsControls` setting is enabled.
   *
   * @access private
   */
  initializeOpenQuickSettings () {
    if (this.openQuickSettings || this.standAlone) { return }

    this.openQuickSettings = document.createElement(&apos;div&apos;)
    this.openQuickSettings.classList.add(&apos;open-minimap-quick-settings&apos;)
    this.controls.appendChild(this.openQuickSettings)

    this.openQuickSettingSubscription = this.subscribeTo(this.openQuickSettings, {
      &apos;mousedown&apos;: (e) =&gt; {
        e.preventDefault()
        e.stopPropagation()

        if ((this.quickSettingsElement != null)) {
          this.quickSettingsElement.destroy()
          this.quickSettingsSubscription.dispose()
        } else {
          this.quickSettingsElement = new MinimapQuickSettingsElement()
          this.quickSettingsElement.setModel(this)
          this.quickSettingsSubscription = this.quickSettingsElement.onDidDestroy(() =&gt; {
            this.quickSettingsElement = null
          })

          let {top, left, right} = this.getFrontCanvas().getBoundingClientRect()
          this.quickSettingsElement.style.top = top + &apos;px&apos;
          this.quickSettingsElement.attach()

          if (this.displayMinimapOnLeft) {
            this.quickSettingsElement.style.left = (right) + &apos;px&apos;
          } else {
            this.quickSettingsElement.style.left = (left - this.quickSettingsElement.clientWidth) + &apos;px&apos;
          }
        }
      }
    })
  }

  /**
   * Disposes the quick settings openener div when the `displayPluginsControls`
   * setting is disabled.
   *
   * @access private
   */
  disposeOpenQuickSettings () {
    if (!this.openQuickSettings) { return }

    this.controls.removeChild(this.openQuickSettings)
    this.openQuickSettingSubscription.dispose()
    delete this.openQuickSettings
  }

  /**
   * Returns the target `TextEditor` of the Minimap.
   *
   * @return {TextEditor} the minimap&apos;s text editor
   */
  getTextEditor () { return this.minimap.getTextEditor() }

  /**
   * Returns the `TextEditorElement` for the Minimap&apos;s `TextEditor`.
   *
   * @return {TextEditorElement} the minimap&apos;s text editor element
   */
  getTextEditorElement () {
    if (this.editorElement) { return this.editorElement }

    this.editorElement = atom.views.getView(this.getTextEditor())
    return this.editorElement
  }

  /**
   * Returns the root of the `TextEditorElement` content.
   *
   * This method is mostly used to ensure compatibility with the `shadowDom`
   * setting.
   *
   * @return {HTMLElement} the root of the `TextEditorElement` content
   */
  getTextEditorElementRoot () {
    let editorElement = this.getTextEditorElement()

    if (editorElement.shadowRoot) {
      return editorElement.shadowRoot
    } else {
      return editorElement
    }
  }

  /**
   * Returns the root where to inject the dummy node used to read DOM styles.
   *
   * @param  {boolean} shadowRoot whether to use the text editor shadow DOM
   *                              or not
   * @return {HTMLElement} the root node where appending the dummy node
   * @access private
   */
  getDummyDOMRoot (shadowRoot) {
    if (shadowRoot) {
      return this.getTextEditorElementRoot()
    } else {
      return this.getTextEditorElement()
    }
  }

  //    ##     ##  #######  ########  ######## ##
  //    ###   ### ##     ## ##     ## ##       ##
  //    #### #### ##     ## ##     ## ##       ##
  //    ## ### ## ##     ## ##     ## ######   ##
  //    ##     ## ##     ## ##     ## ##       ##
  //    ##     ## ##     ## ##     ## ##       ##
  //    ##     ##  #######  ########  ######## ########

  /**
   * Returns the Minimap for which this MinimapElement was created.
   *
   * @return {Minimap} this element&apos;s Minimap
   */
  getModel () { return this.minimap }

  /**
   * Defines the Minimap model for this MinimapElement instance.
   *
   * @param  {Minimap} minimap the Minimap model for this instance.
   * @return {Minimap} this element&apos;s Minimap
   */
  setModel (minimap) {
    this.minimap = minimap
    this.subscriptions.add(this.minimap.onDidChangeScrollTop(() =&gt; {
      this.requestUpdate()
    }))
    this.subscriptions.add(this.minimap.onDidChangeScrollLeft(() =&gt; {
      this.requestUpdate()
    }))
    this.subscriptions.add(this.minimap.onDidDestroy(() =&gt; {
      this.destroy()
    }))
    this.subscriptions.add(this.minimap.onDidChangeConfig(() =&gt; {
      if (this.attached) { return this.requestForcedUpdate() }
    }))

    this.subscriptions.add(this.minimap.onDidChangeStandAlone(() =&gt; {
      this.setStandAlone(this.minimap.isStandAlone())
      this.requestUpdate()
    }))

    this.subscriptions.add(this.minimap.onDidChange((change) =&gt; {
      this.pendingChanges.push(change)
      this.requestUpdate()
    }))

    this.subscriptions.add(this.minimap.onDidChangeDecorationRange((change) =&gt; {
      this.pendingDecorationChanges.push(change)
      this.requestUpdate()
    }))

    this.setStandAlone(this.minimap.isStandAlone())

    if (this.width != null &amp;&amp; this.height != null) {
      this.minimap.setScreenHeightAndWidth(this.height, this.width)
    }

    return this.minimap
  }

  /**
   * Sets the stand-alone mode for this MinimapElement.
   *
   * @param {boolean} standAlone the new mode for this MinimapElement
   */
  setStandAlone (standAlone) {
    this.standAlone = standAlone

    if (this.standAlone) {
      this.setAttribute(&apos;stand-alone&apos;, true)
      this.disposeScrollIndicator()
      this.disposeOpenQuickSettings()
      this.removeControls()
      this.removeVisibleArea()
    } else {
      this.removeAttribute(&apos;stand-alone&apos;)
      this.createVisibleArea()
      this.createControls()
      if (this.minimapScrollIndicator) { this.initializeScrollIndicator() }
      if (this.displayPluginsControls) { this.initializeOpenQuickSettings() }
    }
  }

  //    ##     ## ########  ########     ###    ######## ########
  //    ##     ## ##     ## ##     ##   ## ##      ##    ##
  //    ##     ## ##     ## ##     ##  ##   ##     ##    ##
  //    ##     ## ########  ##     ## ##     ##    ##    ######
  //    ##     ## ##        ##     ## #########    ##    ##
  //    ##     ## ##        ##     ## ##     ##    ##    ##
  //     #######  ##        ########  ##     ##    ##    ########

  /**
   * Requests an update to be performed on the next frame.
   */
  requestUpdate () {
    if (this.frameRequested) { return }

    this.frameRequested = true
    requestAnimationFrame(() =&gt; {
      this.update()
      this.frameRequested = false
    })
  }

  /**
   * Requests an update to be performed on the next frame that will completely
   * redraw the minimap.
   */
  requestForcedUpdate () {
    this.offscreenFirstRow = null
    this.offscreenLastRow = null
    this.requestUpdate()
  }

  /**
   * Performs the actual MinimapElement update.
   *
   * @access private
   */
  update () {
    if (!(this.attached &amp;&amp; this.isVisible() &amp;&amp; this.minimap)) { return }
    let minimap = this.minimap
    minimap.enableCache()
    let canvas = this.getFrontCanvas()

    let visibleAreaLeft = minimap.getTextEditorScaledScrollLeft()
    let visibleAreaTop = minimap.getTextEditorScaledScrollTop() - minimap.getScrollTop()
    let visibleWidth = Math.min(canvas.width / devicePixelRatio, this.width)

    if (this.adjustToSoftWrap &amp;&amp; this.flexBasis) {
      this.style.flexBasis = this.flexBasis + &apos;px&apos;
    } else {
      this.style.flexBasis = null
    }

    if (SPEC_MODE) {
      this.applyStyles(this.visibleArea, {
        width: visibleWidth + &apos;px&apos;,
        height: minimap.getTextEditorScaledHeight() + &apos;px&apos;,
        top: visibleAreaTop + &apos;px&apos;,
        left: visibleAreaLeft + &apos;px&apos;
      })
    } else {
      this.applyStyles(this.visibleArea, {
        width: visibleWidth + &apos;px&apos;,
        height: minimap.getTextEditorScaledHeight() + &apos;px&apos;,
        transform: this.makeTranslate(visibleAreaLeft, visibleAreaTop)
      })
    }

    this.applyStyles(this.controls, {width: visibleWidth + &apos;px&apos;})

    let canvasTop = minimap.getFirstVisibleScreenRow() * minimap.getLineHeight() - minimap.getScrollTop()

    let canvasTransform = this.makeTranslate(0, canvasTop)
    if (devicePixelRatio !== 1) {
      canvasTransform += &apos; &apos; + this.makeScale(1 / devicePixelRatio)
    }

    if (SPEC_MODE) {
      this.applyStyles(this.backLayer.canvas, {top: canvasTop + &apos;px&apos;})
      this.applyStyles(this.tokensLayer.canvas, {top: canvasTop + &apos;px&apos;})
      this.applyStyles(this.frontLayer.canvas, {top: canvasTop + &apos;px&apos;})
    } else {
      this.applyStyles(this.backLayer.canvas, {transform: canvasTransform})
      this.applyStyles(this.tokensLayer.canvas, {transform: canvasTransform})
      this.applyStyles(this.frontLayer.canvas, {transform: canvasTransform})
    }

    if (this.minimapScrollIndicator &amp;&amp; minimap.canScroll() &amp;&amp; !this.scrollIndicator) {
      this.initializeScrollIndicator()
    }

    if (this.scrollIndicator != null) {
      let minimapScreenHeight = minimap.getScreenHeight()
      let indicatorHeight = minimapScreenHeight * (minimapScreenHeight / minimap.getHeight())
      let indicatorScroll = (minimapScreenHeight - indicatorHeight) * minimap.getCapedTextEditorScrollRatio()

      if (SPEC_MODE) {
        this.applyStyles(this.scrollIndicator, {
          height: indicatorHeight + &apos;px&apos;,
          top: indicatorScroll + &apos;px&apos;
        })
      } else {
        this.applyStyles(this.scrollIndicator, {
          height: indicatorHeight + &apos;px&apos;,
          transform: this.makeTranslate(0, indicatorScroll)
        })
      }

      if (!minimap.canScroll()) { this.disposeScrollIndicator() }
    }

    this.updateCanvas()
    minimap.clearCache()
  }

  /**
   * Defines whether to render the code highlights or not.
   *
   * @param {Boolean} displayCodeHighlights whether to render the code
   *                                        highlights or not
   */
  setDisplayCodeHighlights (displayCodeHighlights) {
    this.displayCodeHighlights = displayCodeHighlights
    if (this.attached) { this.requestForcedUpdate() }
  }

  /**
   * Polling callback used to detect visibility and size changes.
   *
   * @access private
   */
  pollDOM () {
    let visibilityChanged = this.checkForVisibilityChange()
    if (this.isVisible()) {
      if (!this.wasVisible) { this.requestForcedUpdate() }

      this.measureHeightAndWidth(visibilityChanged, false)
    }
  }

  /**
   * A method that checks for visibility changes in the MinimapElement.
   * The method returns `true` when the visibility changed from visible to
   * hidden or from hidden to visible.
   *
   * @return {boolean} whether the visibility changed or not since the last call
   * @access private
   */
  checkForVisibilityChange () {
    if (this.isVisible()) {
      if (this.wasVisible) {
        return false
      } else {
        this.wasVisible = true
        return this.wasVisible
      }
    } else {
      if (this.wasVisible) {
        this.wasVisible = false
        return true
      } else {
        this.wasVisible = false
        return this.wasVisible
      }
    }
  }

  /**
   * A method used to measure the size of the MinimapElement and update internal
   * components based on the new size.
   *
   * @param  {boolean} visibilityChanged did the visibility changed since last
   *                                     measurement
   * @param  {[type]} [forceUpdate=true] forces the update even when no changes
   *                                     were detected
   * @access private
   */
  measureHeightAndWidth (visibilityChanged, forceUpdate = true) {
    if (!this.minimap) { return }

    let wasResized = this.width !== this.clientWidth || this.height !== this.clientHeight

    this.height = this.clientHeight
    this.width = this.clientWidth
    let canvasWidth = this.width

    if ((this.minimap != null)) { this.minimap.setScreenHeightAndWidth(this.height, this.width) }

    if (wasResized || visibilityChanged || forceUpdate) { this.requestForcedUpdate() }

    if (!this.isVisible()) { return }

    if (wasResized || forceUpdate) {
      if (this.adjustToSoftWrap) {
        let lineLength = atom.config.get(&apos;editor.preferredLineLength&apos;)
        let softWrap = atom.config.get(&apos;editor.softWrap&apos;)
        let softWrapAtPreferredLineLength = atom.config.get(&apos;editor.softWrapAtPreferredLineLength&apos;)
        let width = lineLength * this.minimap.getCharWidth()

        if (softWrap &amp;&amp; softWrapAtPreferredLineLength &amp;&amp; lineLength &amp;&amp; width &lt;= this.width) {
          this.flexBasis = width
          canvasWidth = width
        } else {
          delete this.flexBasis
        }
      } else {
        delete this.flexBasis
      }

      let canvas = this.getFrontCanvas()
      if (canvasWidth !== canvas.width || this.height !== canvas.height) {
        this.setCanvasesSize(
          canvasWidth * devicePixelRatio,
          (this.height + this.minimap.getLineHeight()) * devicePixelRatio
        )
      }
    }
  }

  //    ######## ##     ## ######## ##    ## ########  ######
  //    ##       ##     ## ##       ###   ##    ##    ##    ##
  //    ##       ##     ## ##       ####  ##    ##    ##
  //    ######   ##     ## ######   ## ## ##    ##     ######
  //    ##        ##   ##  ##       ##  ####    ##          ##
  //    ##         ## ##   ##       ##   ###    ##    ##    ##
  //    ########    ###    ######## ##    ##    ##     ######

  /**
   * Helper method to register config observers.
   *
   * @param  {Object} configs={} an object mapping the config name to observe
   *                             with the function to call back when a change
   *                             occurs
   * @access private
   */
  observeConfig (configs = {}) {
    for (let config in configs) {
      this.subscriptions.add(atom.config.observe(config, configs[config]))
    }
  }

  /**
   * Callback triggered when the mouse is pressed on the MinimapElement canvas.
   *
   * @param  {MouseEvent} e the mouse event object
   * @access private
   */
  mousePressedOverCanvas (e) {
    if (this.minimap.isStandAlone()) { return }
    if (e.which === 1) {
      this.leftMousePressedOverCanvas(e)
    } else if (e.which === 2) {
      this.middleMousePressedOverCanvas(e)
      let {top, height} = this.visibleArea.getBoundingClientRect()
      this.startDrag({which: 2, pageY: top + height / 2}) // ugly hack
    }
  }

  /**
   * Callback triggered when the mouse left button is pressed on the
   * MinimapElement canvas.
   *
   * @param  {MouseEvent} e the mouse event object
   * @param  {number} e.pageY the mouse y position in page
   * @param  {HTMLElement} e.target the source of the event
   * @access private
   */
  leftMousePressedOverCanvas ({pageY, target}) {
    let y = pageY - target.getBoundingClientRect().top
    let row = Math.floor(y / this.minimap.getLineHeight()) + this.minimap.getFirstVisibleScreenRow()

    let textEditor = this.minimap.getTextEditor()

    let scrollTop = row * textEditor.getLineHeightInPixels() - this.minimap.getTextEditorHeight() / 2

    if (atom.config.get(&apos;minimap.scrollAnimation&apos;)) {
      let from = this.minimap.getTextEditorScrollTop()
      let to = scrollTop
      let step = (now) =&gt; this.minimap.setTextEditorScrollTop(now)
      let duration = atom.config.get(&apos;minimap.scrollAnimationDuration&apos;)
      this.animate({from: from, to: to, duration: duration, step: step})
    } else {
      this.minimap.setTextEditorScrollTop(scrollTop)
    }
  }

  /**
   * Callback triggered when the mouse middle button is pressed on the
   * MinimapElement canvas.
   *
   * @param  {MouseEvent} e the mouse event object
   * @param  {number} e.pageY the mouse y position in page
   * @access private
   */
  middleMousePressedOverCanvas ({pageY}) {
    let {top: offsetTop} = this.getBoundingClientRect()
    let y = pageY - offsetTop - this.minimap.getTextEditorScaledHeight() / 2

    let ratio = y / (this.minimap.getVisibleHeight() - this.minimap.getTextEditorScaledHeight())

    this.minimap.setTextEditorScrollTop(ratio * this.minimap.getTextEditorMaxScrollTop())
  }

  /**
   * A method that relays the `mousewheel` events received by the MinimapElement
   * to the `TextEditorElement`.
   *
   * @param  {MouseEvent} e the mouse event object
   * @access private
   */
  relayMousewheelEvent (e) {
    this.getTextEditorElement().component.onMouseWheel(e)
  }

  //    ########    ####    ########
  //    ##     ##  ##  ##   ##     ##
  //    ##     ##   ####    ##     ##
  //    ##     ##  ####     ##     ##
  //    ##     ## ##  ## ## ##     ##
  //    ##     ## ##   ##   ##     ##
  //    ########   ####  ## ########

  /**
   * A method triggered when the mouse is pressed over the visible area that
   * starts the dragging gesture.
   *
   * @param  {MouseEvent} e the mouse event object
   * @access private
   */
  startDrag (e) {
    let {which, pageY} = e
    if (!this.minimap) { return }
    if (which !== 1 &amp;&amp; which !== 2 &amp;&amp; !(e.touches != null)) { return }

    let {top} = this.visibleArea.getBoundingClientRect()
    let {top: offsetTop} = this.getBoundingClientRect()

    let dragOffset = pageY - top

    let initial = {dragOffset, offsetTop}

    let mousemoveHandler = (e) =&gt; this.drag(e, initial)
    let mouseupHandler = (e) =&gt; this.endDrag(e, initial)

    document.body.addEventListener(&apos;mousemove&apos;, mousemoveHandler)
    document.body.addEventListener(&apos;mouseup&apos;, mouseupHandler)
    document.body.addEventListener(&apos;mouseleave&apos;, mouseupHandler)

    document.body.addEventListener(&apos;touchmove&apos;, mousemoveHandler)
    document.body.addEventListener(&apos;touchend&apos;, mouseupHandler)

    this.dragSubscription = new Disposable(function () {
      document.body.removeEventListener(&apos;mousemove&apos;, mousemoveHandler)
      document.body.removeEventListener(&apos;mouseup&apos;, mouseupHandler)
      document.body.removeEventListener(&apos;mouseleave&apos;, mouseupHandler)

      document.body.removeEventListener(&apos;touchmove&apos;, mousemoveHandler)
      document.body.removeEventListener(&apos;touchend&apos;, mouseupHandler)
    })
  }

  /**
   * The method called during the drag gesture.
   *
   * @param  {MouseEvent} e the mouse event object
   * @param  {Object} initial
   * @param  {number} initial.dragOffset the mouse offset within the visible
   *                                     area
   * @param  {number} initial.offsetTop the MinimapElement offset at the moment
   *                                    of the drag start
   * @access private
   */
  drag (e, initial) {
    if (!this.minimap) { return }
    if (e.which !== 1 &amp;&amp; e.which !== 2 &amp;&amp; !(e.touches != null)) { return }
    let y = e.pageY - initial.offsetTop - initial.dragOffset

    let ratio = y / (this.minimap.getVisibleHeight() - this.minimap.getTextEditorScaledHeight())

    this.minimap.setTextEditorScrollTop(ratio * this.minimap.getTextEditorMaxScrollTop())
  }

  /**
   * The method that ends the drag gesture.
   *
   * @param  {MouseEvent} e the mouse event object
   * @param  {Object} initial
   * @param  {number} initial.dragOffset the mouse offset within the visible
   *                                     area
   * @param  {number} initial.offsetTop the MinimapElement offset at the moment
   *                                    of the drag start
   * @access private
   */
  endDrag (e, initial) {
    if (!this.minimap) { return }
    this.dragSubscription.dispose()
  }

  //     ######   ######   ######
  //    ##    ## ##    ## ##    ##
  //    ##       ##       ##
  //    ##        ######   ######
  //    ##             ##       ##
  //    ##    ## ##    ## ##    ##
  //     ######   ######   ######

  /**
   * Applies the passed-in styles properties to the specified element
   *
   * @param  {HTMLElement} element the element onto which apply the styles
   * @param  {Object} styles the styles to apply
   * @access private
   */
  applyStyles (element, styles) {
    if (!element) { return }

    let cssText = &apos;&apos;
    for (let property in styles) {
      cssText += `${property}: ${styles[property]}; `
    }

    element.style.cssText = cssText
  }

  /**
   * Returns a string with a CSS translation tranform value.
   *
   * @param  {number} [x = 0] the x offset of the translation
   * @param  {number} [y = 0] the y offset of the translation
   * @return {string} the CSS translation string
   * @access private
   */
  makeTranslate (x = 0, y = 0) {
    if (this.useHardwareAcceleration) {
      return `translate3d(${x}px, ${y}px, 0)`
    } else {
      return `translate(${x}px, ${y}px)`
    }
  }

  /**
   * Returns a string with a CSS scaling tranform value.
   *
   * @param  {number} [x = 0] the x scaling factor
   * @param  {number} [y = 0] the y scaling factor
   * @return {string} the CSS scaling string
   * @access private
   */
  makeScale (x = 0, y = x) {
    if (this.useHardwareAcceleration) {
      return `scale3d(${x}, ${y}, 1)`
    } else {
      return `scale(${x}, ${y})`
    }
  }

  /**
   * A method that return the current time as a Date.
   *
   * That method exist so that we can mock it in tests.
   *
   * @return {Date} the current time as Date
   * @access private
   */
  getTime () { return new Date() }

  /**
   * A method that mimic the jQuery `animate` method and used to animate the
   * scroll when clicking on the MinimapElement canvas.
   *
   * @param  {Object} param the animation data object
   * @param  {[type]} param.from the start value
   * @param  {[type]} param.to the end value
   * @param  {[type]} param.duration the animation duration
   * @param  {[type]} param.step the easing function for the animation
   * @access private
   */
  animate ({from, to, duration, step}) {
    let progress
    let start = this.getTime()

    let swing = function (progress) {
      return 0.5 - Math.cos(progress * Math.PI) / 2
    }

    let update = () =&gt; {
      let passed = this.getTime() - start
      if (duration === 0) {
        progress = 1
      } else {
        progress = passed / duration
      }
      if (progress &gt; 1) { progress = 1 }
      let delta = swing(progress)
      step(from + (to - from) * delta)

      if (progress &lt; 1) { requestAnimationFrame(update) }
    }

    update()
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.3)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
