<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/main.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/atom-minimap/minimap" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/decoration.js~Decoration.html">Decoration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/main.js~Main.html">Main</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/minimap-element.js~MinimapElement.html">MinimapElement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/minimap.js~Minimap.html">Minimap</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">decorators</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-element">element</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-include">include</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">mixins</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/mixins/canvas-drawer.js~CanvasDrawer.html">CanvasDrawer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/mixins/decoration-management.js~DecorationManagement.html">DecorationManagement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/mixins/dom-styles-reader.js~DOMStylesReader.html">DOMStylesReader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/mixins/plugin-management.js~PluginManagement.html">PluginManagement</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/main.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use babel&apos;

import {Emitter, CompositeDisposable} from &apos;atom&apos;
import include from &apos;./decorators/include&apos;
import Minimap from &apos;./minimap&apos;
import MinimapElement from &apos;./minimap-element&apos;
import PluginManagement from &apos;./mixins/plugin-management&apos;
import MinimapPluginGeneratorElement from &apos;./minimap-plugin-generator-element&apos;

/**
 * The `Minimap` package provides an eagle-eye view of text buffers.
 *
 * It also provides API for plugin packages that want to interact with the
 * minimap and be available to the user through the minimap settings.
 */
@include(PluginManagement)
class Main {
  /**
   * Used only at export time.
   *
   * @access private
   */
  constructor () {
    /**
     * The activation state of the package.
     *
     * @type {boolean}
     * @access private
     */
    this.active = false
    /**
     * The toggle state of the package.
     *
     * @type {boolean}
     * @access private
     */
    this.toggled = false
    /**
     * The `Map` where Minimap instances are stored with the text editor they
     * target as key.
     *
     * @type {Map}
     * @access private
     */
    this.editorsMinimaps = null
    /**
     * The composite disposable that stores the package&apos;s subscriptions.
     *
     * @type {CompositeDisposable}
     * @access private
     */
    this.subscriptions = null
    /**
     * The disposable that stores the package&apos;s commands subscription.
     *
     * @type {Disposable}
     * @access private
     */
    this.subscriptionsOfCommands = null
    /**
     * The package&apos;s config object.
     *
     * @type {Object}
     * @access private
     */
    this.config = require(&apos;./config-schema.json&apos;)
    /**
     * The package&apos;s events emitter.
     *
     * @type {Emitter}
     * @access private
     */
    this.emitter = new Emitter()

    this.initializePlugins()
  }

  /**
   * Activates the minimap package.
   */
  activate () {
    if (this.active) { return }

    MinimapElement.registerViewProvider()

    this.subscriptionsOfCommands = atom.commands.add(&apos;atom-workspace&apos;, {
      &apos;minimap:toggle&apos;: () =&gt; {
        this.toggle()
      },
      &apos;minimap:generate-coffee-plugin&apos;: () =&gt; {
        this.generatePlugin(&apos;coffee&apos;)
      },
      &apos;minimap:generate-javascript-plugin&apos;: () =&gt; {
        this.generatePlugin(&apos;javascript&apos;)
      },
      &apos;minimap:generate-babel-plugin&apos;: () =&gt; {
        this.generatePlugin(&apos;babel&apos;)
      }
    })

    this.editorsMinimaps = new Map()
    this.subscriptions = new CompositeDisposable()
    this.active = true

    if (atom.config.get(&apos;minimap.autoToggle&apos;)) { this.toggle() }
  }

  /**
   * Deactivates the minimap package.
   */
  deactivate () {
    if (!this.active) { return }

    this.deactivateAllPlugins()

    if (this.editorsMinimaps) {
      this.editorsMinimaps.forEach((value, key) =&gt; {
        value.destroy()
        this.editorsMinimaps.delete(key)
      })
    }

    this.subscriptions.dispose()
    this.subscriptions = null
    this.subscriptionsOfCommands.dispose()
    this.subscriptionsOfCommands = null
    this.editorsMinimaps = undefined
    this.toggled = false
    this.active = false
  }

  /**
   * Toggles the minimap display.
   */
  toggle () {
    if (!this.active) { return }

    if (this.toggled) {
      this.toggled = false

      if (this.editorsMinimaps) {
        this.editorsMinimaps.forEach((value, key) =&gt; {
          value.destroy()
          this.editorsMinimaps.delete(key)
        })
      }
      this.subscriptions.dispose()
    } else {
      this.toggled = true
      this.initSubscriptions()
    }
  }

  /**
   * Opens the plugin generation view.
   *
   * @param  {string} template the name of the template to use
   */
  generatePlugin (template) {
    var view = new MinimapPluginGeneratorElement()
    view.template = template
    view.attach()
  }

  /**
   * Registers a callback to listen to the `did-activate` event of the package.
   *
   * @param  {function(event:Object):void} callback the callback function
   * @return {Disposable} a disposable to stop listening to the event
   */
  onDidActivate (callback) {
    return this.emitter.on(&apos;did-activate&apos;, callback)
  }

  /**
   * Registers a callback to listen to the `did-deactivate` event of the
   * package.
   *
   * @param  {function(event:Object):void} callback the callback function
   * @return {Disposable} a disposable to stop listening to the event
   */
  onDidDeactivate (callback) {
    return this.emitter.on(&apos;did-deactivate&apos;, callback)
  }

  /**
   * Registers a callback to listen to the `did-create-minimap` event of the
   * package.
   *
   * @param  {function(event:Object):void} callback the callback function
   * @return {Disposable} a disposable to stop listening to the event
   */
  onDidCreateMinimap (callback) {
    return this.emitter.on(&apos;did-create-minimap&apos;, callback)
  }

  /**
   * Registers a callback to listen to the `did-add-plugin` event of the
   * package.
   *
   * @param  {function(event:Object):void} callback the callback function
   * @return {Disposable} a disposable to stop listening to the event
   */
  onDidAddPlugin (callback) {
    return this.emitter.on(&apos;did-add-plugin&apos;, callback)
  }

  /**
   * Registers a callback to listen to the `did-remove-plugin` event of the
   * package.
   *
   * @param  {function(event:Object):void} callback the callback function
   * @return {Disposable} a disposable to stop listening to the event
   */
  onDidRemovePlugin (callback) {
    return this.emitter.on(&apos;did-remove-plugin&apos;, callback)
  }

  /**
   * Registers a callback to listen to the `did-activate-plugin` event of the
   * package.
   *
   * @param  {function(event:Object):void} callback the callback function
   * @return {Disposable} a disposable to stop listening to the event
   */
  onDidActivatePlugin (callback) {
    return this.emitter.on(&apos;did-activate-plugin&apos;, callback)
  }

  /**
   * Registers a callback to listen to the `did-deactivate-plugin` event of the
   * package.
   *
   * @param  {function(event:Object):void} callback the callback function
   * @return {Disposable} a disposable to stop listening to the event
   */
  onDidDeactivatePlugin (callback) {
    return this.emitter.on(&apos;did-deactivate-plugin&apos;, callback)
  }

  /**
   * Returns the `Minimap` class
   *
   * @return {Function} the `Minimap` class constructor
   */
  minimapClass () { return Minimap }

  /**
   * Returns the `Minimap` object associated to the passed-in
   * `TextEditorElement`.
   *
   * @param  {TextEditorElement} editorElement a text editor element
   * @return {Minimap} the associated minimap
   */
  minimapForEditorElement (editorElement) {
    if (!editorElement) { return }
    return this.minimapForEditor(editorElement.getModel())
  }

  /**
   * Returns the `Minimap` object associated to the passed-in
   * `TextEditor`.
   *
   * @param  {TextEditor} textEditor a text editor
   * @return {Minimap} the associated minimap
   */
  minimapForEditor (textEditor) {
    if (!textEditor) { return }

    let minimap = this.editorsMinimaps.get(textEditor)

    if (!minimap) {
      minimap = new Minimap({textEditor})
      this.editorsMinimaps.set(textEditor, minimap)

      var editorSubscription = textEditor.onDidDestroy(() =&gt; {
        let minimaps = this.editorsMinimaps
        if (minimaps) { minimaps.delete(textEditor) }
        editorSubscription.dispose()
      })
    }

    return minimap
  }

  /**
   * Returns a new stand-alone {Minimap} for the passed-in `TextEditor`.
   *
   * @param  {TextEditor} textEditor a text editor instance to create
   *                                 a minimap for
   * @return {Minimap} a new stand-alone Minimap for the passed-in editor
   */
  standAloneMinimapForEditor (textEditor) {
    if (!textEditor) { return }

    return new Minimap({
      textEditor: textEditor,
      standAlone: true
    })
  }

  /**
   * Returns the `Minimap` associated to the active `TextEditor`.
   *
   * @return {Minimap} the active Minimap
   */
  getActiveMinimap () {
    return this.minimapForEditor(atom.workspace.getActiveTextEditor())
  }

  /**
   * Calls a function for each present and future minimaps.
   *
   * @param  {function(minimap:Minimap):void} iterator a function to call with
   *                                                   the existing and future
   *                                                   minimaps
   * @return {Disposable} a disposable to unregister the observer
   */
  observeMinimaps (iterator) {
    if (!iterator) { return }

    if (this.editorsMinimaps) {
      this.editorsMinimaps.forEach((minimap) =&gt; { iterator(minimap) })
    }
    return this.onDidCreateMinimap((minimap) =&gt; { iterator(minimap) })
  }

  /**
   * Registers to the `observeTextEditors` method.
   *
   * @access private
   */
  initSubscriptions () {
    this.subscriptions.add(atom.workspace.observeTextEditors((textEditor) =&gt; {
      let minimap = this.minimapForEditor(textEditor)
      let minimapElement = atom.views.getView(minimap)

      this.emitter.emit(&apos;did-create-minimap&apos;, minimap)

      minimapElement.attach()
    }))
  }
}

/**
 * The exposed instance of the `Main` class.
 *
 * @access private
 */
export default new Main()
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.3)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
